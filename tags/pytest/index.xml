<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pytest on Invalid Input</title>
    <link>/tags/pytest/index.xml</link>
    <description>Recent content in Pytest on Invalid Input</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/tags/pytest/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Testing Flask SQLAlchemy database with pytest</title>
      <link>/2017/07/03/testing-flask-sqlalchemy-database-with-pytest/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/07/03/testing-flask-sqlalchemy-database-with-pytest/</guid>
      <description>&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://testdriven.io/part-one-test-setup/&#34;&gt;Early in the tutorial&lt;/a&gt;, the author explains how to set up your app to use &lt;a href=&#34;https://docs.python.org/3/library/unittest.html&#34;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&#34;https://github.com/jarus/flask-testing&#34;&gt;&lt;code&gt;Flask-Testing&lt;/code&gt;&lt;/a&gt; extension for its test framework. Since I wanted to use &lt;a href=&#34;https://docs.pytest.org/en/latest/&#34;&gt;&lt;code&gt;pytest&lt;/code&gt;&lt;/a&gt;, this was a good opportunity to explore the test setup a bit more in depth.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;running-pytest-from-a-script&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Running pytest from a script&lt;/h2&gt;
&lt;p&gt;Firstly, add &lt;code&gt;pytest&lt;/code&gt; to your &lt;code&gt;requirements.txt&lt;/code&gt; and place a dummy test in the &lt;code&gt;project/tests&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;def test_dummy():
    assert True&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Secondly, add a &lt;code&gt;manager.command&lt;/code&gt; to &lt;code&gt;manage.py&lt;/code&gt; that run the pytest tests.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# manage.py
import pytest
@manager.command
def test():
    &amp;quot;&amp;quot;&amp;quot;Runs the tests.&amp;quot;&amp;quot;&amp;quot;
    pytest.main([&amp;quot;-s&amp;quot;, &amp;quot;project/tests&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some notes: - To find info on calling pytest directly from python code, go &lt;a href=&#34;https://docs.pytest.org/en/latest/usage.html#calling-pytest-from-python-code&#34;&gt;here&lt;/a&gt; - I first tried to just run &lt;code&gt;pytest.main()&lt;/code&gt; and ended up with some “File not found” error. You need to provide an empty list &lt;code&gt;[]&lt;/code&gt; at the very least. The error is discussed more in depth &lt;a href=&#34;https://github.com/pytest-dev/pytest/issues/1110&#34;&gt;here&lt;/a&gt;. - Running &lt;code&gt;pytest.main([])&lt;/code&gt; with an empty list will look for test everywhere in your project. If you have placed the &lt;code&gt;env&lt;/code&gt; dir in &lt;code&gt;/project&lt;/code&gt;, with all the sources of your virtual environment packages, you might find tons of tests that you did not want to touch. Therefore, it’s better to target specifically the &lt;code&gt;project/tests&lt;/code&gt; dir with the last argument &lt;code&gt;project/tests&lt;/code&gt;. - Adding &lt;code&gt;-s&lt;/code&gt; to the pytest command lets pytest print to the console any print statements that you use in your tests, not just the ones from failing tests.&lt;/p&gt;
&lt;p&gt;We can now run the test on the running containers with:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;$ docker-compose run users-service python manage.py test 

== test session starts ==
platform linux -- Python 3.6.1, pytest-3.1.2, py-1.4.34, pluggy-0.4.0
rootdir: /usr/src/app, inifile:
collected 1 items 

project/tests/test_ping.py .

== 1 passed in 0.01 seconds ==&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;creating-an-app-fixture&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Creating an app fixture&lt;/h2&gt;
&lt;p&gt;In the tutorial, the author creates the class &lt;code&gt;BaseTestCase&lt;/code&gt; in &lt;code&gt;project/tests/base.py&lt;/code&gt;, which imports the &lt;code&gt;app&lt;/code&gt; from &lt;code&gt;project&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# http://testdriven.io/part-one-test-setup/
# project/tests/base.py 
[...]
from project import app, db


class BaseTestCase(TestCase):
    def create_app(self):
        app.config.from_object(&amp;#39;project.config.TestingConfig&amp;#39;)
        return app
[...]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;code&gt;app&lt;/code&gt; instance can then be used in our different tests, without needing to reimport the app for each test. At the beginning of its &lt;code&gt;project/tests/test_users.py&lt;/code&gt;, you can see that the class &lt;code&gt;TestUserService&lt;/code&gt; inherits from &lt;code&gt;BaseTestCase&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# http://testdriven.io/part-one-test-setup/
# project/tests/test_users.py 
[...]
from project.tests.base import BaseTestCase


class TestUserService(BaseTestCase):
[...]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reusable objects for tests are called fixtures. In &lt;code&gt;unittest&lt;/code&gt;, fixtures are defined as classes with two special functions &lt;code&gt;setUp&lt;/code&gt; and &lt;code&gt;tearDown&lt;/code&gt;, that are &lt;a href=&#34;https://docs.python.org/3/library/unittest.html#organizing-test-code&#34;&gt;executed before/after each test&lt;/a&gt;. &lt;a href=&#34;https://docs.pytest.org/en/latest/fixture.html&#34; class=&#34;uri&#34;&gt;https://docs.pytest.org/en/latest/fixture.html&lt;/a&gt;). We will cover their pytest implementations later.&lt;/p&gt;
&lt;p&gt;Rather than importing the app, we will first move the code to the &lt;a href=&#34;http://flask.pocoo.org/docs/0.12/patterns/appfactories/&#34;&gt;Application Factories pattern&lt;/a&gt; (also used in the tutorial &lt;a href=&#34;http://testdriven.io/part-one-flask-blueprints/&#34;&gt;soon after&lt;/a&gt;). Rewrite your &lt;code&gt;project/__init__.py&lt;/code&gt; as below:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/__init__.py
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy


db = SQLAlchemy()


class User(db.Model):
    __tablename__ = &amp;quot;users&amp;quot;
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(128), nullable=False)
    email = db.Column(db.String(128), nullable=False)
    active = db.Column(db.Boolean(), default=False, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False)

    def __init__(self, username, email):
        self.username = username
        self.email = email
        self.created_at = datetime.datetime.now()


def create_app():
    app = Flask(__name__)

    app_settings = os.getenv(&amp;#39;APP_SETTINGS&amp;#39;)
    app.config.from_object(app_settings)

    db.init_app(app)

    @app.route(&amp;#39;/ping&amp;#39;, methods=[&amp;#39;GET&amp;#39;])
    def ping_pong():
        return jsonify({
            &amp;#39;status&amp;#39;: &amp;#39;Epic success&amp;#39;,
            &amp;#39;message&amp;#39;: &amp;#39;pong!&amp;#39;
        })

    return app&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We now have a &lt;code&gt;create_app()&lt;/code&gt; function, that can return an &lt;code&gt;app&lt;/code&gt; instance. In pytest, fixture are defined as function, with the &lt;code&gt;@pytest.fixture&lt;/code&gt; decorator.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/tests/conftest.py
import pytest
from project import create_app


@pytest.fixture
def app():
    app = create_app()
    app.config.from_object(&amp;#39;project.config.TestingConfig&amp;#39;)
    return app&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tests in pytest are also just function, named with the prefix &lt;code&gt;test_&lt;/code&gt;. To use a fixture in a test, just add it as an argument. Note that assertions are simpler than in unittest, you only need the &lt;code&gt;assert&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Test the different configurations:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/tests/test_config.py
import os


def test_development_config(app):
    app.config.from_object(&amp;#39;project.config.DevelopmentConfig&amp;#39;)
    assert app.config[&amp;#39;DEBUG&amp;#39;]
    assert not app.config[&amp;#39;TESTING&amp;#39;]
    assert app.config[&amp;#39;SQLALCHEMY_DATABASE_URI&amp;#39;] == os.environ.get(
        &amp;#39;DATABASE_URL&amp;#39;)


def test_testing_config(app):
    app.config.from_object(&amp;#39;project.config.TestingConfig&amp;#39;)
    assert app.config[&amp;#39;DEBUG&amp;#39;]
    assert app.config[&amp;#39;TESTING&amp;#39;]
    assert not app.config[&amp;#39;PRESERVE_CONTEXT_ON_EXCEPTION&amp;#39;]
    assert app.config[&amp;#39;SQLALCHEMY_DATABASE_URI&amp;#39;] == os.environ.get(
        &amp;#39;DATABASE_TEST_URL&amp;#39;)


def test_production_config(app):
    app.config.from_object(&amp;#39;project.config.ProductionConfig&amp;#39;)
    assert not app.config[&amp;#39;DEBUG&amp;#39;]
    assert not app.config[&amp;#39;TESTING&amp;#39;]
    assert app.config[&amp;#39;SQLALCHEMY_DATABASE_URI&amp;#39;] == os.environ.get(
        &amp;#39;DATABASE_URL&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Testing the ping route (using &lt;a href=&#34;http://flask.pocoo.org/docs/0.12/api/#flask.Flask.test_client&#34;&gt;&lt;code&gt;test_client()&lt;/code&gt;&lt;/a&gt; to get a &lt;code&gt;client&lt;/code&gt; that can test routes):&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/tests/test_ping.py
import json


def test_ping(app):
    client = app.test_client()
    resp = client.get(&amp;#39;/ping&amp;#39;)
    data = json.loads(resp.data.decode())
    assert resp.status_code == 200
    assert &amp;#39;pong&amp;#39; in data[&amp;#39;message&amp;#39;]
    assert &amp;#39;success&amp;#39; in data[&amp;#39;status&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;accessing-the-database-from-the-tests&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Accessing the database from the tests&lt;/h2&gt;
&lt;div id=&#34;making-tables-accessible-with-create_all&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Making tables accessible with &lt;code&gt;create_all()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;So far we haven’t put any code related to the database in our &lt;code&gt;app&lt;/code&gt; fixture. The tutorial has done so in &lt;code&gt;BaseTestCase&lt;/code&gt;. If we rewrite the &lt;a href=&#34;http://testdriven.io/part-one-restful-routes/&#34;&gt;&lt;code&gt;test_add_user&lt;/code&gt;&lt;/a&gt; for pytest and try to run it, we get an error.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/tests/test_users.py
def test_add_user(app):
    &amp;quot;&amp;quot;&amp;quot;Ensure a new user can be added to the database.&amp;quot;&amp;quot;&amp;quot;
    with app.test_client() as client:
        response = client.post(
            &amp;#39;/users&amp;#39;,
            data=json.dumps(dict(
                username=&amp;#39;michael&amp;#39;,
                email=&amp;#39;michael@realpython.com&amp;#39;
            )),
            content_type=&amp;#39;application/json&amp;#39;,
        )
        data = json.loads(response.data.decode())
        assert response.status_code == 201
        assert &amp;#39;michael@realpython.com was added!&amp;#39; in data[&amp;#39;message&amp;#39;]
        assert &amp;#39;success&amp;#39; in data[&amp;#39;status&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;$ docker-compose run users-service python manage.py test_app
[...]
======= FAILURES ======
____ test_add_user ____
[...]
sqlalchemy.exc.ProgrammingError: (psycopg2.ProgrammingError) relation &amp;quot;users&amp;quot; does not exist&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So our app fixture knows about sql alchemy but hasn’t created the tables needed for our user model. From the &lt;a href=&#34;http://flask-sqlalchemy.pocoo.org/2.1/contexts/&#34;&gt;Flask-SQLAlchemy documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What it (init_db) does is prepare the application to work with SQLAlchemy. However that does not now bind the SQLAlchemy object to your application.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s jump in an python shell and try to see how we can bind our &lt;code&gt;db&lt;/code&gt; object to our &lt;code&gt;app&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;$ docker exec -ti users-service bash
root@910656bc5f75:/usr/src/app# python3
&amp;gt;&amp;gt;&amp;gt; from project import create_app, db
&amp;gt;&amp;gt;&amp;gt; app = create_app()
&amp;gt;&amp;gt;&amp;gt; app
&amp;lt;Flask &amp;#39;project&amp;#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; db
&amp;lt;SQLAlchemy engine=None&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;create_app()&lt;/code&gt; gives us an app object, but the imported &lt;code&gt;db&lt;/code&gt; isn’t connected to it out-of-the-box (it has no engine). If we jump into the &lt;a href=&#34;http://flask-sqlalchemy.pocoo.org/2.1/contexts/&#34;&gt;app context&lt;/a&gt;, the engine gets populated.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; app_ctx = app.app_context()
&amp;gt;&amp;gt;&amp;gt; app_ctx.push()  # jump into the app context
&amp;gt;&amp;gt;&amp;gt; db
&amp;lt;SQLAlchemy engine=&amp;#39;postgres://postgres:postgres@users-db:5432/users_dev&amp;#39;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, &lt;code&gt;db&lt;/code&gt; still doesn’t have tables and running tests at this stage would keep saying that &lt;code&gt;relation users does not exist&lt;/code&gt;. That’s why we need &lt;code&gt;create_table()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db.engine.table_names()  # Check the tables currently on the engine
[]                           # no table found
&amp;gt;&amp;gt;&amp;gt; db.create_all()          # Create the tables according to defined models
&amp;gt;&amp;gt;&amp;gt; db.engine.table_names()
[&amp;#39;users&amp;#39;]                    # Now table &amp;#39;users&amp;#39; is found&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now update our &lt;code&gt;app&lt;/code&gt; fixture:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/tests/conftest.py
import pytest
from project import create_app, db


@pytest.fixture
def app():
    app = create_app()
    app.config.from_object(&amp;#39;project.config.TestingConfig&amp;#39;)
    with app.app_context():   
        # alternative pattern to app.app_context().push()
        # all commands indented under &amp;#39;with&amp;#39; are run in the app context 
        db.create_all()
        return app&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;cleaning-database-with-drop_all&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Cleaning database with &lt;code&gt;drop_all()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Let’s check the impact of our tests on the database. Before running tests:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;$ docker exec -ti $(docker ps -aqf &amp;quot;name=users-db&amp;quot;) psql -U postgres

psql (9.6.3)
postgres=# \c users_dev
You are now connected to database &amp;quot;users_dev&amp;quot; as user &amp;quot;postgres&amp;quot;.
users_dev=# \dt
No relations found.
users_dev=# \c users_test
You are now connected to database &amp;quot;users_test&amp;quot; as user &amp;quot;postgres&amp;quot;.
users_test=# \dt
No relations found.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After running tests:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# Running pytest
$ docker-compose run users-service python manage.py test_app
[... Output of pytest ...]
========= 5 passed in 0.17 seconds =========

# Checking the database
$ docker exec -ti $(docker ps -aqf &amp;quot;name=users-db&amp;quot;) psql -U postgres

psql (9.6.3)
postgres=# \c users_dev
You are now connected to database &amp;quot;users_dev&amp;quot; as user &amp;quot;postgres&amp;quot;.
users_dev=# \dt
No relations found.
users_dev=# \c users_test
You are now connected to database &amp;quot;users_test&amp;quot; as user &amp;quot;postgres&amp;quot;.
users_test=# \dt
users_test=# \dt
         List of relations
 Schema | Name  | Type  |  Owner   
--------+-------+-------+----------
 public | users | table | postgres
(1 row)

users_test=# SELECT * FROM users;
 id | username |         email          | active |         created_at         
----+----------+------------------------+--------+----------------------------
  1 | michael  | michael@realpython.com | f      | 2017-07-04 09:23:43.34457&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that the users table was successfully created in the &lt;code&gt;users_test&lt;/code&gt; database, which we selected in &lt;code&gt;conftest.py&lt;/code&gt;. A user was also successfully inserted. However, if we run the tests again and recheck the table, we can see how trouble is starting to creep in:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# Running test 
[...]

# Checking the database
[...]
users_test=# SELECT * FROM users;
 id | username |         email          | active |         created_at         
----+----------+------------------------+--------+----------------------------
  1 | michael  | michael@realpython.com | f      | 2017-07-04 09:23:43.34457
  2 | michael  | michael@realpython.com | f      | 2017-07-04 09:24:55.972571
(2 rows)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are not cleaning up the database after our tests. To do so, we need to add &lt;code&gt;drop_all()&lt;/code&gt; as a tear-down action for our app fixture (after &lt;code&gt;yield&lt;/code&gt;). This will not only empty the table rows, but also delete the table itself:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/tests/conftest.py
import pytest
from project import create_app, db


@pytest.fixture
def app():
    app = create_app()
    app.config.from_object(&amp;#39;project.config.TestingConfig&amp;#39;)
    with app.app_context():   
        db.create_all()
        yield app   # Note that we changed return for yield, see below for why
        db.drop_all()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the first time, we added a command (&lt;code&gt;db.drop_all()&lt;/code&gt;) that needed to be executed after the test using the fixture. Previously we used &lt;code&gt;return&lt;/code&gt; to get the app out of the fixture. But using &lt;code&gt;return&lt;/code&gt; means ending the function. That’s where &lt;code&gt;yield&lt;/code&gt; comes to the rescue. Unlike &lt;code&gt;unittest&lt;/code&gt;, &lt;code&gt;pytest&lt;/code&gt; does not put setup and teardown code in dedicated function. Everything that comes before &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;yield&lt;/code&gt; is setup code, everything that comes after &lt;code&gt;yield&lt;/code&gt; is teardown code. Documentation is &lt;a href=&#34;https://docs.pytest.org/en/latest/fixture.html#fixture-finalization-executing-teardown-code&#34;&gt;here&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By using a yield statement instead of return, all the code after the yield statement serves as the teardown code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you try to run tests again, you will see that the database is left clean.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;avoid-locking-postgres-with-db.session.remove&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Avoid locking postgres with &lt;code&gt;db.session.remove()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This is the part I still have trouble understanding. Using the fixture above, &lt;code&gt;pytest&lt;/code&gt; started hanging indefinitely at random test (usually at tests that touched the database several times, but not always). When it happened, I could not even stop &lt;code&gt;pytest&lt;/code&gt; and had to restart the container.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;$ docker-compose run users-service python manage.py test_app
===== test session starts =====
[...]
project/tests/test_configs.py ...
project/tests/test_users.py ..

hanging... hanging... hanging...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this &lt;a href=&#34;https://stackoverflow.com/questions/26350911/what-to-do-when-a-py-test-hangs-silently&#34;&gt;SO question&lt;/a&gt;, I got the confirmation that postgres might be locked. Using &lt;a href=&#34;https://www.devopsderek.com/blog/2012/11/13/list-and-disconnect-postgresql-db-sessions/&#34;&gt;the commands listed on devopsderek.com&lt;/a&gt;, it is possible to look at the sessions active while pytest is locked. Below we can see that one is blocked with the state &lt;a href=&#34;https://stackoverflow.com/questions/51019/what-does-it-mean-when-a-postgresql-process-is-idle-in-transaction&#34;&gt;“idle in transaction”&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# Checking the database while pytest is hanging
$ docker exec -ti $(docker ps -aqf &amp;quot;name=users-db&amp;quot;) psql -U postgres
postgres=# SELECT * FROM pg_stat_activity;

datid |  datname   | pid | ... | state               | ... | query
------+------------+-----+-----+---------------------+-----+-
[... lots of sessions ...]
16386 | users_test | 200 | ... | idle in transaction | ... | SELECT users.id...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Killing the session manually in postgres did also kill &lt;code&gt;pytest&lt;/code&gt; without needing to restart the container.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# Still in psql
postgres=# SELECT pg_terminate_backend(200);
 pg_terminate_backend 
----------------------
 t
(1 row)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# In the terminal running pytest
psycopg2.OperationalError: terminating connection due to administrator command
server closed the connection unexpectedly
    This probably means the server terminated abnormally
    before or while processing the request.
$ # free to type again&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Still following &lt;a href=&#34;https://stackoverflow.com/questions/26350911/what-to-do-when-a-py-test-hangs-silently&#34;&gt;SO advice&lt;/a&gt;, you can explicitly close the connection after each test, which solves the issue.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/tests/conftest.py
import pytest
from project import create_app, db


@pytest.fixture
def app():
    app = create_app()
    app.config.from_object(&amp;#39;project.config.TestingConfig&amp;#39;)
    with app.app_context():   
        db.create_all()
        yield app  
        db.session.remove()  # looks like db.session.close() would work as well
        db.drop_all()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We end up very close to the &lt;a href=&#34;http://testdriven.io/part-one-test-setup/&#34;&gt;testdriven.io example&lt;/a&gt; for &lt;code&gt;unittest&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# project/tests/base.py on http://testdriven.io/part-one-test-setup/
from flask_testing import TestCase

from project import app, db


class BaseTestCase(TestCase):
    def create_app(self):  # done in our pytest fixture before yield
        app.config.from_object(&amp;#39;project.config.TestingConfig&amp;#39;)
        return app
        
    def setUp(self):  # done in our pytest fixture before yield
        db.create_all()
        db.session.commit()

    def tearDown(self): # done in our pytest fixture after yield
        db.session.remove()
        db.drop_all()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I just haven’t found the reason why &lt;code&gt;db.session.commit()&lt;/code&gt; would be necessary (although I suspect it might be an alternative to explicitely declaring the app context like we did in &lt;code&gt;with&lt;/code&gt;). I will update the post when I understand it better.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>